#!/usr/bin/env ruby

# Copyright 2017 Noragh Analytics, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied.
#
# See the License for the specific language governing permissions and
# limitations under the License.
#
require 'bundler/setup'

require 'sinatra'
require 'thin'

require_relative '../lib/armagh/environment.rb'
Armagh::Environment.init

require 'armagh/support/templating'

require_relative '../lib/armagh/admin/application/admin_gui.rb'

Process.setproctitle(File.basename(__FILE__))

gui = Armagh::Admin::Application::AdminGUI.instance

include Armagh::Support::Templating

enable :sessions, :logging

configure do
  if ENV[ 'ARMAGH_ENV' ] == 'PRODUCTION'
    set :environment,     :production
    set :show_exceptions, false
  else
    set :environment,     :development
    set :show_exceptions, true
  end

  set :bind,            gui.ip
  set :port,            gui.port
  set :server,          'thin'
  set :root,            Proc.new { gui.root_directory }
  set :public_folder,   Proc.new { File.join(settings.root, 'public') }
  set :views,           Proc.new { File.join(settings.root, 'views') }
  set :run,             true
end

use Rack::CommonLogger, gui.logger

helpers do
  def render(*page, **context)
    page.map! { |p| p.to_s }
    page = File.join(page)
    context[:page]   = page
    context[:error]  = replace_new_line_with_br(context[:error])  if context[:error]
    context[:notice] = replace_new_line_with_br(context[:notice]) if context[:notice]
    render_template(File.join(settings.views, 'layout.erubis'), :html, context)
  end

  def partial(*page, **context)
    page.map! { |p| p.to_s }
    page = File.join(page)
    template_config(mode: :html)
    render_partial(File.join(settings.views, "#{page}.erubis"), context)
  end

  def url_path(path)
    url(path)
  end

  def active_domain(page_to_check = '')
    request.path_info[/^\/#{page_to_check}(?:\/|\?|$)/] ? 'uk-active' : ''
  end

  def replace_new_line_with_br(content)
    case content
    when String
      content.gsub(/\n/, '<br />')
    when Array
      Array(content).map { |value| value.gsub(/\n/, '<br />') }
    else
      raise "Unexpected content class provided to replace_new_line_with_br: #{content.class}"
    end
  end

  def authenticated?
    !user.nil?
  end

  def user
    session['user']
  end

  def proper_case(value)
    return '' if value.to_s.strip.empty?
    value
      .split('_')
      .map { |word| word.capitalize }
      .join(' ')
  end

  def sanitize_string(value)
    return value unless value.is_a?(String)
    value
      .gsub(/&/, '&amp;')
      .gsub(/</, '&lt;')
      .gsub(/>/, '&gt;')
      .gsub(/"/, '&quot;')
      .gsub(/'/, '&#39;')
      .gsub(/\//, '&#x2F;')
      .gsub(/`/, '&#x60;')
      .gsub(/=/, '&#x3D;')
      .strip
  end
end

not_found do
  halt 404, render(:error, error: "404: <strong>#{request.path_info}</strong> does not exist" )
end

error do |e|
  render :error, error: e.message
end

before do
  pass if request.path_info[/^\/login/] || gui.authenticated?
  redirect "/login?re=#{request.path_info}"
end

#
# login
#

get '/login' do
  render :login
end

post '/login' do
  if %w[username password].all? { |k| params.key? k }
    username         = params['username']
    password         = params['password']
    status, response = gui.login(username, password)
    case status
    when :error
      session['user'] = nil
      halt render :login, error: response
    when :change_password
      session['change_password'] = {user_id:  response, username: username}
      render :login, :change_password, notice: 'It seems this may be your first login. Please change your password using the form below.'
    when :success
      session['user']       = response[:name] || username
      session['user_id']    = response[:id]
      session['user_roles'] = response[:roles]
      redirect params['re']
    end
  elsif %w[old new con].all? { |k| params.key? k }
    change_password  = session['change_password']
    user_id          = change_password[:user_id]
    username         = change_password[:username]
    status, response = gui.change_password(user_id, username, params)
    case status
    when :error
      render(:login, :change_password, error: response)
    when :success
      session['change_password'] = nil
      session['user']       = response['name'] || username
      session['user_id']    = user_id
      session['user_roles'] = response['roles']
      redirect params['re']
    end
  end
end

get '/logout' do
  gui.logout
  session['user'] = nil
  redirect '/'
end

#
# home
#

get '/' do
  render :home
end

#
# status
#

get '/status' do
  render :status, data: gui.get_status
end

patch '/restart' do
  gui.shutdown(restart: true)
end

patch '/shutdown' do
  gui.shutdown
end

#
# logs
#

get '/logs' do
  data = gui.get_logs(
    page:   params['page'],
    limit:  params['limit'],
    sort:  {params['sort_col']=>params['sort_dir']},
    filter: params['filter'],
    hide:   params['hide']
  )
  errors = data.delete(:errors)
  render :logs, data: data, error: errors
end

#
# docs
#

get '/docs' do
  render :docs, data: gui.get_doc_collections
end

get '/docs/:collection' do
  partial :docs, :doc, data: gui.get_doc(params)
end

#
# workflow config
#

get '/config' do
  render :config, :workflows, data: gui.get_workflows
end

get '/config/new' do
  render :config, :workflow_new
end

post '/config/new' do
  workflow = params['workflow']

  halt render(:config, :workflow_new, error: 'Workflow name cannot be empty') if workflow.to_s.strip.empty?

  status, response = gui.create_workflow(workflow)
  if status == :success
    redirect "/config/#{workflow}"
  else
    data = {value: workflow}
    halt render(:config, :workflow_new, data: data, error: response['message'])
  end
end

get '/config/:workflow' do
  workflow = params['workflow']
  created  = params['created']
  updated  = params['updated']
  data     = gui.get_workflow(workflow, created, updated)
  success  = "Successfully #{created ? 'created' : 'updated'} action <strong>#{created ? created : updated}</strong>." if created || updated
  render :config, :workflow_edit, data: data, success: success
end

get '/config/:workflow/new' do
  render :config, :action_new, data: gui.new_workflow_action(params['workflow'], params['prev'], params['filter'])
end

post '/config/:workflow/new' do
  redirect "/config/#{params['workflow']}/new/#{params['action']}"
end

post '/config/:workflow/import' do
  gui.import_action_config(params)
end

get '/config/:workflow/export' do
  workflow = params['workflow']
  headers['Content-Type']        = 'application/json'
  headers['Content-Disposition'] = "attachment;filename=#{workflow}.json"
  gui.export_workflow_config(workflow)
end

patch '/config/:workflow/:status_change' do
  workflow = params['workflow']
  if params['status_change'] == 'activate'
    gui.activate_workflow(workflow)
      .unshift(params['id'])
      .to_json
  else
    gui.deactivate_workflow(workflow)
      .unshift(params['id'])
      .to_json
  end
end

#
# action config
#

get '/config/:workflow/new/:action' do
  render :config, :action_edit, data: gui.new_action_config(params['workflow'], params['action'])
end

post '/config/:workflow/new/:action' do
  workflow = params['workflow']
  result   = gui.create_action_config(params)
  if result == :success
    redirect "/config/#{workflow}?created=#{params['action-name']}"
  else
    render :config, :action_edit, data: result.first, error: result.last
  end
end

get '/config/:workflow/edit/:action' do
  render :config, :action_edit, data: gui.edit_workflow_action(params['workflow'], params['action'])
end

put '/config/:workflow/edit/:action' do
  workflow = params['workflow']
  action   = params['action']
  result   = gui.update_action_config(params)
  if result == :success
    redirect "/config/#{workflow}?updated=#{action}"
  else
    render :config, :action_edit, data: result.first, error: result.last
  end
end

patch '/config/test' do
  data = JSON.parse(request.body.read)
  gui.invoke_action_test_callback(data)
end
