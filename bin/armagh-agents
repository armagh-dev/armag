#!/usr/bin/env ruby
#
# Copyright 2016 Noragh Analytics, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied.
#
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Caution: Since this script is distributed as part of a gem, when run from PATH it wont be executed as part of a bundle (even with require 'bundler/setup')
#            If any of the required need a specific version and there is a chance that multiple versions will be installed on the system, specify the gem version
#            as part of the requirement as well as in the gemspec.

require 'rubygems'
require 'bundler/setup'

require 'drb/unix'
require 'fileutils'
require 'socket'

require 'log4r'

require_relative '../lib/agent/agent'
require_relative '../lib/agent/agent_status'
require_relative '../lib/action/action_manager'
require_relative '../lib/configuration/agent_config_manager'
require_relative '../lib/configuration/launcher_config_manager'
require_relative '../lib/connection'
require_relative '../lib/ipc'
require_relative '../lib/logging'
require_relative '../lib/version'

include Armagh

TERM_SIGNALS = [:INT, :QUIT, :TERM]

Logging.init_log_env

unless Connection.can_connect?
  $stderr.puts "Unable to establish connection to the MongoConnection database configured in '#{Configuration::FileBasedConfiguration.filepath}'.  Ensure the database is running."
  exit 1
end

@logger = Log4r::Logger['Armagh::Application::Launcher'] || Log4r::Logger.new('Armagh::Application::Launcher')

@launcher_config_manager = Configuration::LauncherConfigManager.new(@logger)
@agent_config_manager = Configuration::AgentConfigManager.new(@logger)

@hostname = Socket.gethostname
@agents = {}
@restart_agents = true
@running = false

def reconcile_agents
  reported_agents = AgentStatus.get_statuses(@agent_status).keys
  running_agents = @agents.values.collect{|a| a.uuid}

  reported_not_running = reported_agents - running_agents
  running_not_reported = running_agents - reported_agents

  reported_not_running.each {|id| @agent_status.remove_agent(id) }

  @logger.error "The following agents are reported but not running: #{reported_not_running}" unless reported_not_running.empty?
  @logger.error "The following agents are running but not reporting: #{running_not_reported}" unless running_not_reported.empty?
end

def checkin(status)
  @logger.info "Checking In: #{status}"

  checkin = {
      'version' => VERSION,
      'last_update' => Time.now,
      'status' => status,

      'agents' => AgentStatus.get_statuses(@agent_status),

      'actions' => {'custom' => {}, 'standard' => {}},
  }

  checkin['actions']['custom'] = {'name' => CustomActions::NAME, 'version' => CustomActions::VERSION} if defined? CustomActions
  checkin['actions']['standard'] = {'version' => StandardActions::VERSION} if defined? StandardActions

  @logger.debug "Checkin Details: #{checkin}"
  Connection.status.find('_id' => @hostname).replace_one(checkin, {upsert: true})

  @last_checkin = Time.now
end

def apply_launcher_config(config)
  change_log_level(config['log_level'])
  change_num_agents(config['num_agents'])
  @logger.debug "Updated configuration to #{config}"
end

def apply_agent_config(config)
  @agent_status.config = config
end

def change_log_level(level)
  unless @logger.level == level
    @logger.any "Changing log level to #{@logger.levels[level]}"
    @logger.level = level
  end
end

def change_num_agents(num_agents)
  running_agents = @agents.length
  @logger.debug "Changing number of agents from #{running_agents} to #{num_agents}"

  if running_agents < num_agents
    @logger.info "Increasing number of agents from #{running_agents} to #{num_agents}"
    launch_agents(num_agents - running_agents)
  elsif running_agents > num_agents
    @logger.info "Decreasing number of agents from #{running_agents} to #{num_agents}"
    kill_agents(running_agents - num_agents)
  end
end

def launch_agents(num_agents)
  @logger.debug "Launching #{num_agents} agents"
  num_agents.times do
    start_agent_in_process
  end
  sleep 1
end

def kill_all_agents(signal = :SIGINT)
  kill_agents(@agents.length, signal)
end

def kill_agents(num_agents, signal = :SIGINT)
  num_agents.times do
    killed_pid = stop_agent(signal)
    agent_id = @agents[killed_pid].uuid
    @agents.delete killed_pid
    @agent_status.remove_agent(agent_id)
  end
end

def recover_dead_agents
  dead_agents = []
  @agents.each do |pid, agent|
    unless process_running(pid)
      _pid, status = Process.wait2(pid)
      @logger.error "Agent #{agent.uuid} (PID: #{pid}) terminated with exit code #{status}. Restarting it"
      dead_agents << agent
      agent_id = @agents[pid].uuid
      @agents.delete(pid)
      @agent_status.remove_agent(agent_id)
    end
  end

  dead_agents.each do |agent|
    start_agent_in_process(agent)
  end
end

def process_running(pid)
  Process.getpgid( pid )
  true
rescue Errno::ESRCH
  false
end

def start_agent_in_process(agent=nil)
  agent ||= Agent.new

  pid = Process.fork do
    TERM_SIGNALS.each do |signal|
      trap(signal) {agent.stop}
    end
    begin
      agent.start
    rescue => e
      Logging.error_exception(@logger, e, "Could not start agent #{agent.uuid}")
    end
  end

  @agents[pid] = agent
end

def stop_agent(signal)
  pid = @agents.keys.first
  Process.kill(signal, pid)
  pid = Process.wait
  pid
end

def shutdown(signal)
  Thread.new{ @logger.any "Received #{signal}.  Shutting down once agents finish" }
  @running = false
  Thread.new{ kill_all_agents(signal) }
end

def update_config
  new_config = @launcher_config_manager.get_config
  if new_config
    @config = new_config
    apply_launcher_config(@config)
  else
    @logger.debug 'Ignoring launcher configuration update.'
  end
end

def update_agent_config
  agent_config = @agent_config_manager.get_config
  apply_agent_config(agent_config)
end

def load_actions
  begin
    require 'armagh/custom_actions'
    @logger.info "Using CustomActions: #{Armagh::CustomActions::NAME} (#{CustomActions::VERSION})"
  rescue LoadError
    @logger.warn "CustomActions gem is not deployed. These actions won't be available."
  rescue => e
    # An unexpected exception - things like syntax errors.
    Logging.error_exception(@logger, e, 'Could not load CustomActions gem')
    Armagh.send(:remove_const, :CustomActions)
  end

  begin
    require 'armagh/standard_actions'
    @logger.info "Using StandardActions: #{Standard::VERSION}"
  rescue LoadError
    @logger.warn "StandardActions gem is not deployed. These actions won't be available."
  rescue => e
    # An unexpected exception - things like syntax errors.
    Logging.error_exception(@logger, e, 'Could not load StandardActions gem')
    Armagh.send(:remove_const, :StandardActions)
  end

  defined_actions = ActionManager.defined_actions

  if defined_actions.any?
    @logger.debug "Available actions are: #{defined_actions}"
  else
    @logger.warn 'No defined actions.  Please make sure Standard and/or Custom Actions are installed.'
  end
end

# Stop agents before stopping armagh
TERM_SIGNALS.each do |signal|
  trap(signal) { shutdown(signal) }
end

## Execution ##
begin
  @logger.any 'Armagh started'

  @agent_status = AgentStatus.new
  @server = DRb.start_service(IPC::DRB_URI, @agent_status)

  @config = @launcher_config_manager.get_config

  if @config.nil?
    @logger.error 'Invalid initial launcher configuration.  Exiting.'
    exit 1
  end

  change_log_level(@config['log_level'])

  load_actions

  update_agent_config

  if @agent_status.config.nil?
    @logger.error 'Invalid initial agent configuration.  Exiting.'
    exit 1
  end

  apply_launcher_config(@config)

  @running = true
  checkin('running')

  while @running do
    if @last_checkin.nil? || @last_checkin < Time.now - @config['checkin_frequency']
      reconcile_agents
      update_config
      update_agent_config
      checkin('running')
    end

    recover_dead_agents
    sleep 1
  end

rescue => e
  @logger.error 'An unexpected error occurred.  Exiting.'
  @logger.error e
  kill_all_agents(:SIGINT)
  @exit_status = 1
end

checkin('stopping')

Process.waitall
@server.stop_service

checkin('stopped')

@logger.any 'Armagh stopped'

exit @exit_status if @exit_status
